<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huang Yujie&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/bb904430b38398d2d1ab671d0d4cc8de</icon>
  <subtitle>Welcome to my blog!</subtitle>
  <link href="https://nobodyyj.github.io/atom.xml" rel="self"/>
  
  <link href="https://nobodyyj.github.io/"/>
  <updated>2024-02-22T13:02:06.139Z</updated>
  <id>https://nobodyyj.github.io/</id>
  
  <author>
    <name>Huang Yujie</name>
    <email>struggle_hyj@outlook.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>统计学习学习记录</title>
    <link href="https://nobodyyj.github.io/post/e5e13074.html"/>
    <id>https://nobodyyj.github.io/post/e5e13074.html</id>
    <published>2024-02-21T11:30:58.000Z</published>
    <updated>2024-02-22T13:02:06.139Z</updated>
    
    <content type="html"><![CDATA[<p>作为非科班出身的金数人，在学习机器学习模型时我发现自对一些最基础、最本质的概念理解不够深入，所以打算写一篇blog，记录一下自己在学习的时候遇到的零零散散的问题。</p><h2 id="极大似然估计mle和损失函数的关系">1.极大似然估计(MLE)和损失函数的关系</h2><ol type="1"><li>若变量服从高斯分布，MLE的结果是OLS</li><li>若变量服从伯努利分布，MLE的结果是logistich回归</li><li>若变量服从多项式分布，MLE的结果是softmax</li></ol><h2 id="当我们对损失函数正则化时我们在做什么">2.当我们对损失函数正则化时，我们在做什么？</h2><p>做正则化的目的就是为了提高训练出模型的泛化能力。影响模型泛化能力的是权重<span class="math inline">\(w\)</span> 和偏置 <span class="math inline">\(b\)</span> 。</p><p><a href="https://www.bilibili.com/video/BV1Z44y147xA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=44ba9a7b92cb9c058705d88870afca92">“L1和L2正则化”直观理解</a></p><ol type="1"><li><p>拉格朗日对偶角度</p><figure><img src="/post/e5e13074/image-20240221221538595.png" alt="image-20240221221538595"><figcaption aria-hidden="true">image-20240221221538595</figcaption></figure><figure><img src="/post/e5e13074/image-20240221223742439.png" alt="image-20240221223742439"><figcaption aria-hidden="true">image-20240221223742439</figcaption></figure><blockquote><p>为什么说L1正则化（右）可以带来稀疏性，就是因为L1正则化后的极值点容易出现在坐标轴上，而出现在坐标轴上意味着其他某些维度的值为0，比如要用胡子和毛色区分猫咪和狗，L2正则化（左）可能只是赋予两个特征不同的权重，<span class="math inline">\(\lambda\)</span>的作用是来调节权重大小，而L1正则化就可能只考虑胡子，而不考虑毛色，这就带来了<strong>稀疏性</strong>。</p></blockquote></li><li><p>权重衰减角度</p></li><li><p>贝叶斯角度</p></li><li><p>模型复杂度角度</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为非科班出身的金数人，在学习机器学习模型时我发现自对一些最基础、最本质的概念理解不够深入，所以打算写一篇blog，记录一下自己在学习的时候遇到的零零散散的问题。&lt;/p&gt;
&lt;h2 id=&quot;极大似然估计mle和损失函数的关系&quot;&gt;1.极大似然估计(MLE)和损失函数的关系&lt;/</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://nobodyyj.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>大四下学期to-do list</title>
    <link href="https://nobodyyj.github.io/post/3331babe.html"/>
    <id>https://nobodyyj.github.io/post/3331babe.html</id>
    <published>2024-02-18T02:38:39.000Z</published>
    <updated>2024-02-18T02:46:24.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大四下-to-do-list"><a href="#大四下-to-do-list" class="headerlink" title="大四下 to-do list"></a>大四下 to-do list</h1><ul><li>[ ] 找到一份日薪200+的方向合适的量化实习</li><li>[ ] 出去旅游</li><li>[ ] 参加一次kaggle比赛（<a href="https://www.kaggle.com/competitions/home-credit-credit-risk-model-stability">信贷风险模型</a>)</li><li>[ ] 完成个人回测系统的搭建</li><li>[ ] crypto实盘</li></ul><hr><p>2024-2-18</p><hr><p>2024-2-18：</p><p>更细的拆分，应该是要同时补上数据结构、算法方面的漏洞（量化实习考试+央财课内考试）+ 机器学习方面的空白</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大四下-to-do-list&quot;&gt;&lt;a href=&quot;#大四下-to-do-list&quot; class=&quot;headerlink&quot; title=&quot;大四下 to-do list&quot;&gt;&lt;/a&gt;大四下 to-do list&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;[ ] 找到一份日薪200+的方</summary>
      
    
    
    
    
    <category term="to-do list" scheme="https://nobodyyj.github.io/tags/to-do-list/"/>
    
  </entry>
  
  <entry>
    <title>从零开始在vscode上配置C++运行环境</title>
    <link href="https://nobodyyj.github.io/post/d38d0dd6.html"/>
    <id>https://nobodyyj.github.io/post/d38d0dd6.html</id>
    <published>2024-02-06T11:55:40.000Z</published>
    <updated>2024-02-18T02:37:49.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始在vscode上配置c运行环境">从零开始在vscode上配置C++运行环境</h1><p>​本文用于记录我在配置C++时遇到的坑。之前在配置的时候是花钱找tb帮忙做的，这次打算记录下来这个过程，以便后续复现。</p><h2 id="安装mingw编译器">1.安装MinGW编译器</h2><p>​ 需要从<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">SourceForge.net</a>处下载MinGW编译器.</p><h3 id="选择合适的版本">1.1 选择合适的版本</h3><figure><img src="/post/d38d0dd6/image-20240206200640071.png" alt="image-20240206200640071"><figcaption aria-hidden="true">image-20240206200640071</figcaption></figure><figure><img src="/post/d38d0dd6/v2-2d0276533469f23e148dbe7b8e688b85_720w.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="配置系统环境">1.2 配置系统环境</h3><p>将（比如我的是D:_64-8.1.0-release-posix-seh-rt_v6-rev0）添加入电脑系统环境<img src="https://pic1.zhimg.com/80/v2-aa4899ab623657407ad5dca167a5bf80_720w.webp" alt="img"></p><figure><img src="/post/d38d0dd6/image-20240206201139096.png" alt="image-20240206201139096"><figcaption aria-hidden="true">image-20240206201139096</figcaption></figure><h3 id="验证是否成功安装">1.3 验证是否成功安装</h3><p>打开cmd，输入<code>gcc -v</code></p><figure><img src="/post/d38d0dd6/image-20240206201212569.png" alt="image-20240206201212569"><figcaption aria-hidden="true">image-20240206201212569</figcaption></figure><p>出现上述内容说明安装成功</p><h2 id="在vscode中安装cc插件">2.在vscode中安装C/C++插件</h2><figure><img src="/post/d38d0dd6/image-20240206200423060.png" alt="image-20240206200423060"><figcaption aria-hidden="true">image-20240206200423060</figcaption></figure><h2 id="配置cc环境">3.配置C/C++环境</h2><figure><img src="/post/d38d0dd6/v2-0b4821eecf84239ddd2cb1770e6520c3_720w.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>可以先建立 .vscode文件夹</p><h3 id="配置编译器">3.1 配置编译器</h3><p><strong>（在.vscode文件夹含有c_cpp_properties.json文件）</strong></p><p>首先按快捷键Ctrl+Shift+P调出命令面板，输入C/C++，选择“EditConfigurations(UI)”进入配置。</p><p>接着这里配置两个选项： - 编译器路径：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">D:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin/g++.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的路径根据大家自己安装的Mingw编译器位置和配置的环境变量位置所决定。</p><figure><img src="/post/d38d0dd6/v2-6c92ebccb5ee908a85aaf00e6b266c87_720w.webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>第一步</p><figure><img src="/post/d38d0dd6/v2-30f3dbb1578b72af40fb646ec57c08fb_720w.webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>第二步</p><figure><img src="/post/d38d0dd6/v2-da4e9d35e8e9dadb8b1ed1a64f7a9f90_720w.webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>第三步</p><p>配置完成后，此时在侧边栏可以发现多了一个.vscode文件夹，并且里面有一个c_cpp_properties.json文件，内容如下，说明上述配置成功。现在可以通过**Ctrl+<code>快捷键**打开内置终端并进行编译运行了。（ESC下边的</code>）</p><p><strong>c_cpp_properties.json</strong></p><pre class="line-numbers language-jsonld" data-language="jsonld"><code class="language-jsonld">&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Win32&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;            ],            &quot;defines&quot;: [                &quot;_DEBUG&quot;,                &quot;UNICODE&quot;,                &quot;_UNICODE&quot;            ],            &quot;windowsSdkVersion&quot;: &quot;10.0.17763.0&quot;,            &quot;compilerPath&quot;: &quot;C:\\Program Files\\mingw64\\bin\\gcc.exe&quot;,            &quot;cStandard&quot;: &quot;c17&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;        &#125;    ],    &quot;version&quot;: 4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置构建任务">3.2 配置构建任务</h3><p><strong>（在.vscode文件夹中创建一个tasks.json文件）</strong></p><p>该任务将调用g++编译器基于源代码创建可执行文件。按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:ConfigureDefault Build Task”：</p><figure><img src="/post/d38d0dd6/v2-4c31d3e823dc3e51e44886380484fce2_720w.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>第一步哟</p><p>再选择“C/C++: g++.exe build active file”：</p><figure><img src="/post/d38d0dd6/v2-3836bdbba135f75567e4f0b72b57e5a2_720w.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>第二步呀</p><p>此时会出现一个名为tasks.json的配置文件，内容如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span>    <span class="token comment">// for the documentation about the tasks.json format</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span><span class="token comment">//构建配置项</span>            <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"shell"</span><span class="token punctuation">,</span><span class="token comment">//任务类型,Vscode将预定义变量转义解析后直接传给command;shell->先打开shell再输入命令,因此args会经过shell再次解析</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">" "</span>g++.exe build active file<span class="token string">""</span><span class="token punctuation">,</span><span class="token comment">//任务名称</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\mingw64\\bin\\gcc.exe"</span><span class="token punctuation">,</span><span class="token comment">//记得修改本地编译器路径</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">//包含传给gcc命令的参数,用于实现特定功能</span>                <span class="token string">"-g"</span><span class="token punctuation">,</span> <span class="token comment">//生成和调试有关的信息</span>                <span class="token string">"$&#123;file&#125;"</span><span class="token punctuation">,</span> <span class="token comment">//指定编译文件为当前文件</span>                <span class="token string">"-o"</span><span class="token punctuation">,</span><span class="token comment">//指定输出文件的路径和名称</span>                <span class="token comment">//"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe"</span>                <span class="token string">"$&#123;workspaceFolder&#125;\\build\\$&#123;fileBasenameNoExtension&#125;.exe"</span><span class="token comment">//修改.exe文件生成位置</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//"cwd": "$&#123;fileDirname&#125;"</span>                <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\mingw64\\bin"</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"problemMatcher"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"$gcc"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token comment">//包含很多task,归为group</span>                <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span><span class="token comment">//表名该组任务类型是构建</span>                <span class="token property">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token comment">//表明此任务为此组任务中的默认任务</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"调试器生成的任务。"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><figure><img src="/post/d38d0dd6/v2-113ac7497af63217711d42d1b8ef1cda_720w.webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>可以参考一下</p><p>（本部分参考：<a href="https://zhuanlan.zhihu.com/p/545908287">【详细版】VsCode搭建C++环境- 知乎 (zhihu.com)</a>）</p><hr><p><strong>此时，已经可以正常运行和调试.cpp的文件了！</strong></p><figure><img src="/post/d38d0dd6/image-20240206203324701.png" alt="image-20240206203324701"><figcaption aria-hidden="true">image-20240206203324701</figcaption></figure><p>但是此时编译好的.exe后缀文件会保存在原代码的位置，看起来非常的丑！</p><figure><img src="/post/d38d0dd6/image-20240206203445574.png" alt="image-20240206203445574"><figcaption aria-hidden="true">image-20240206203445574</figcaption></figure><p>我们希望把.exe文件放到bin文件夹中</p><h3 id="设置输出编译后文件至某一文件夹">3.3设置输出编译后文件至某一文件夹</h3><figure><img src="/post/d38d0dd6/image-20240206203843473.png" alt="image-20240206203843473"><figcaption aria-hidden="true">image-20240206203843473</figcaption></figure><p>把这一行代码的输出改为如图所示。</p><figure><img src="/post/d38d0dd6/image-20240206203904210.png" alt="image-20240206203904210"><figcaption aria-hidden="true">image-20240206203904210</figcaption></figure><p><strong>成功！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从零开始在vscode上配置c运行环境&quot;&gt;从零开始在vscode上配置C++运行环境&lt;/h1&gt;
&lt;p&gt;​
本文用于记录我在配置C++时遇到的坑。之前在配置的时候是花钱找tb帮忙做的，这次打算记录下来这个过程，以便后续复现。&lt;/p&gt;
&lt;h2 id=&quot;安装min</summary>
      
    
    
    
    
    <category term="C++" scheme="https://nobodyyj.github.io/tags/C/"/>
    
    <category term="踩坑记录" scheme="https://nobodyyj.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="https://nobodyyj.github.io/post/83b461a0.html"/>
    <id>https://nobodyyj.github.io/post/83b461a0.html</id>
    <published>2024-01-04T15:42:39.000Z</published>
    <updated>2024-01-04T16:04:27.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c学习">C++学习</h1><h2 id="前言">前言</h2><p>​果然DDL是第一生产力，今天是2024-1-4，我一遍恶补金融经济学和金融时间序列，一边准备着1.10要讲的<strong>《类的继承》</strong>，因此特开一个新坑，把自己的学习笔记记录下来。</p><p>学习目的：</p><ol type="1"><li>通过学习C++的程序设计思想优化自己Python的编程能力</li><li>尽早能够使用C++作为leetcode答题语言</li></ol><p>参考书籍：</p><ol type="1"><li>C++ Primer Plus</li><li>Effective C++</li><li>C++语言程序设计（授课书）</li></ol><h2 id="一对象和类">一、对象和类</h2><h3 id="过程性编程和面向对象编程">1.1 过程性编程和面向对象编程</h3><p>​ OOP重要特性：抽象、封装、继承、多态</p><p>​采用过程性编程方法时，主要考虑要遵循的步骤，然后考虑如何表示这些数据。</p><p>​ OOP程序员，不仅考虑如何表示数据集，还考虑如何使用数据： ​比如用一个对象来表示我希望记录的各个方面，作为基本数据单元。并需要将基本信息添加进这个数据单元的方法，和执行计算的方法，以及更新和显示信息的方法。所以，用户与数据交互的方式有三种：<strong>初始化、更新和报告</strong>——这就是<strong>用户接口</strong>。</p><p>​采用OOP方法时，首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。</p><h3 id="抽象和类">1.2 抽象和类</h3><p>​<strong>抽象</strong>：将问题的本质特征抽象出来，以便根据信息与用户之间的接口来表示他。（我的理解是把问题的本质找到，以便转化为code）</p><p>​<strong>类</strong>：类是一种将抽象转化为用户定义类型的C++工具，将数据表示和操纵数据的方法组合成一个整洁的包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c学习&quot;&gt;C++学习&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​
果然DDL是第一生产力，今天是2024-1-4，我一遍恶补金融经济学和金融时间序列，一边准备着1.10要讲的&lt;strong&gt;《类的继承》&lt;/strong&gt;，因此特开一个新坑，把</summary>
      
    
    
    
    
    <category term="C++" scheme="https://nobodyyj.github.io/tags/C/"/>
    
    <category term="学习" scheme="https://nobodyyj.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Barra CNE5</title>
    <link href="https://nobodyyj.github.io/post/8d2ea662.html"/>
    <id>https://nobodyyj.github.io/post/8d2ea662.html</id>
    <published>2024-01-03T01:50:48.000Z</published>
    <updated>2024-01-29T14:56:52.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="barra-cne5">Barra CNE5</h1><h2 id="前言">1.前言</h2><p>本文旨在记录自己在学习和使用Barra CNE5模型的过程，方便未来回忆。</p><h2 id="cne5模型简介">2.CNE5模型简介</h2><p>​ CNE5 是 Barra的最新一代面向中国股票市场的多因子模型。<strong>该模型考虑了一个国家因子、多个行业因子以及多个风格因子。</strong>假设市场中共有N 支股票，P 个行业，以及 Q个风格因子。在任意给定时间点，该模型使用因子暴露和个股收益率构建<strong>截面回归（cross-sectionalregression）</strong>如下：</p><p><span class="math inline">\(\begin{aligned} &amp;{\left[\begin{array}{c}r_1-r_f \\ r_2-r_f \\ \vdots \\r_N-r_f\end{array}\right]=\left[\begin{array}{c}1 \\ 1 \\1\end{array}\right] f_C+\left[\begin{array}{c}X_1^{I_1} \\ X_2^{I_1} \\\vdots \\ X_N^{I_1}\end{array}\right]f_{I_1}+\cdots+\left[\begin{array}{c}X_1^{I_P} \\ X_2^{I_P} \\ \vdots \\X_N^{I_P}\end{array}\right] f_{I_P}+\left[\begin{array}{c}X_1^{S_1} \\X_2^{S_1} \\ \vdots \\ X_1^{S_1} \\ X_2^{S_Q} \\ \vdots \\X_N^{S_Q}\end{array}\right] f_{S_Q}+\left[\begin{array}{c}u_1 \\ u_2 \\\vdots \\ u_N\end{array}\right]}\end{aligned}\)</span></p><p>​ 其中 <span class="math inline">\(r_n\)</span> 是第 <span class="math inline">\(\mathrm{n}\)</span> 支股票的收益率， <span class="math inline">\(r_f\)</span> 是无风险收益率。 <span class="math inline">\(X_n^{I_p}\)</span> 是股票 <span class="math inline">\(\mathrm{n}\)</span> 在行业 <span class="math inline">\(I_p\)</span>的暴露，如果假设一个公司只能属于一个行业，那么 <span class="math inline">\(X_n^{I_p}\)</span> 的取值为 0(代表该股票不属于这个行业) 或者 1 (代表该股票属于这个行业)。 <span class="math inline">\(X_n^{S_q}\)</span> 是股票 <span class="math inline">\(\mathrm{n}\)</span> 在风格因子 <span class="math inline">\(S_q\)</span> 的暴露，它的取值经过了某种标准化（标准化的方法会在下文说明）。 <span class="math inline">\(u_n\)</span>为股票 <span class="math inline">\(\mathrm{n}\)</span>的超额收益中无法被因子解释的部分，因此也被称为该股票的特异性收益。 <span class="math inline">\(f_C\)</span>为国家因子的因子收益率（所有股票在国家因子上的暴露都是1）； <span class="math inline">\(f_{I_p}\)</span> 为行业 <span class="math inline">\(I_p\)</span> 因子的因子收益率; <span class="math inline">\(f_{S_q}\)</span> 为风格因子 <span class="math inline">\(S_q\)</span> 的因子收益率。</p><p>​ 对于给定某一期截面数据（记为 <span class="math inline">\(\mathrm{T}\)</span> 期），在截面回归时，Barra采用期初的因子暴露取值（等价于 <span class="math inline">\(\mathrm{T}\)</span> - 1 期期末的因子暴露取值)和股票在 T 期内的收益率进行截面回归。在 USE4模型中，因子收益率是日频的，因此截面回归也应该是日频的，所以按照上述说明，在<span class="math inline">\(T-1\)</span> 日结束后更新因子的暴露，并利用T 日的股票收益率和因子暴露做截面回归。以下说明来自 Barra Risk ModelHandbook。</p><h2 id="barra10因子">3.Barra10因子</h2><figure><img src="/post/8d2ea662/image-20240129224012714.png" alt="image-20240129224012714"><figcaption aria-hidden="true">image-20240129224012714</figcaption></figure><figure><img src="/post/8d2ea662/image-20240129224028275.png" alt="image-20240129224028275"><figcaption aria-hidden="true">image-20240129224028275</figcaption></figure><h1 id="barra10因子的作用">4.Barra10因子的作用</h1><p>​在得到因子之后，可以从时序上，观察因子值、pnl时序上与10因子的相关系数，来反应该因子在不同风格上的暴露。​此外，还可以考虑加入20DR观察该因子对股价反转因子的暴露。</p><h1 id="风格因子">5.风格？因子？</h1><p>​什么是风格因子，什么是异象因子呢？换言之，我们能否自行选择合适的风格因子来检验某一因子在该方面的风险暴露程度，这个问题值得继续研究。之前在刷研报的时候，似乎也有研究员对size市值因子到底是算风格还是一个市场异象进行过讨论，但是笔者写到这里的时候不记得了（2024-1-2922:46:26），将带着这个问题继续学习~</p><h2 id="参考文献">参考文献</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/38280638">正确理解 Barra的纯因子模型</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;barra-cne5&quot;&gt;Barra CNE5&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;本文旨在记录自己在学习和使用Barra CNE5模型的过程，方便未来回忆。&lt;/p&gt;
&lt;h2 id=&quot;cne5模型简介&quot;&gt;2.CNE5模型简介&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="学习" scheme="https://nobodyyj.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="量化" scheme="https://nobodyyj.github.io/tags/%E9%87%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2023.12.21随笔</title>
    <link href="https://nobodyyj.github.io/post/1738571f.html"/>
    <id>https://nobodyyj.github.io/post/1738571f.html</id>
    <published>2023-12-21T08:28:32.000Z</published>
    <updated>2024-01-04T15:41:19.886Z</updated>
    
    <content type="html"><![CDATA[<p>​最近这半个月一边学习机器学习，一边学习资产定价理论，虽对这两方向的理解与感悟都有了大幅的提升，但是对这两个领域的交叉与结合的意义及原因，却感觉越学越迷糊。因此决定写下这篇文章，以便带着问题继续学习这两门学科。​同时也会附上我在阅读<em>Machine Learning in AssetPricing</em>的疑问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​
最近这半个月一边学习机器学习，一边学习资产定价理论，虽对这两方向的理解与感悟都有了大幅的提升，但是对这两个领域的交叉与结合的意义及原因，却感觉越学越迷糊。因此决定写下这篇文章，以便带着问题继续学习这两门学科。
​同时也会附上我在阅读&lt;em&gt;Machine Learn</summary>
      
    
    
    
    
    <category term="学习" scheme="https://nobodyyj.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器学习" scheme="https://nobodyyj.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学习资源整理</title>
    <link href="https://nobodyyj.github.io/post/bb04665f.html"/>
    <id>https://nobodyyj.github.io/post/bb04665f.html</id>
    <published>2023-12-14T03:10:12.000Z</published>
    <updated>2024-01-04T15:41:19.892Z</updated>
    
    <content type="html"><![CDATA[<p>用于记录我找到的好的学习资源，以便厘清学习的优先度</p><h2 id="一量化平台框架">一、量化平台&amp;框架</h2><h3 id="backtrader">1.BackTrader</h3><p><a href="https://github.com/QuantWorld2022/backtrader">QuantWorld2022/backtrader(github.com)</a></p><h3 id="vnpy">2.Vnpy</h3><p><a href="https://github.com/vnpy/vnpy_algotrading">vnpy/vnpy_algotrading:VeighNa框架的算法交易模块 (github.com)</a></p><h3 id="qlib">3.Qlib</h3><p><a href="https://github.com/microsoft/qlib">[microsoft/qlib: Qlib isan AI-oriented quantitative investment platform that aims to realize thepotential, empower research, and create value using AI technologies inquantitative investment, from exploring ideas to implementingproductions. Qlib supports diverse machine learning modeling paradigms.including supervised learning, market dynamics modeling, and RL.(github.com)](https://github.com/microsoft/qlib)</a></p><h2 id="二python库">二、Python库</h2><h3 id="基于机器学习的凸优化库">1.基于机器学习的凸优化库</h3><p><a href="https://github.com/cvxgrp/cvxpylayers">cvxgrp/cvxpylayers:Differentiable convex optimization layers (github.com)</a></p><h3 id="mlflow">2.mlflow</h3><p><a href="https://www.mlflow.org/">mlflow</a> 用于学习如何管理machinelearning项目周期，并以此作为突破口加深对qlib work flow的认知</p><h2 id="三机器学习">三、机器学习</h2><h3 id="qlib-1">1.Qlib</h3><p><a href="https://github.com/microsoft/qlib">[microsoft/qlib: Qlib isan AI-oriented quantitative investment platform that aims to realize thepotential, empower research, and create value using AI technologies inquantitative investment, from exploring ideas to implementingproductions. Qlib supports diverse machine learning modeling paradigms.including supervised learning, market dynamics modeling, and RL.(github.com)](https://github.com/microsoft/qlib)</a></p><h3 id="深度学习">2.深度学习</h3><p><a href="https://github.com/d2l-ai/d2l-zh">d2l-ai/d2l-zh:《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被70多个国家的500多所大学用于教学。(github.com)</a></p><h2 id="aaamlp">3.AAAMLP</h2><p>https://ytzfhqs.github.io/AAAMLP-CN/</p><p>https://github.com/abhishekkrthakur/approachingalmost/tree/master</p><h2 id="四协方差学习">四、协方差学习</h2><p>shit我居然看不懂一点</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMDEwNDk1Mg==&amp;mid=2650877818&amp;idx=1&amp;sn=79f7794bdaf45b347e9bde0378bc89bc&amp;chksm=8c249eedbb5317fbaa4796aec3837498f2ab3b57b8cc6a21afb0f78a83eb76217d56d8d0c8f2&amp;scene=21#wechat_redirect">正确理解Barra 的纯因子模型</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMDEwNDk1Mg==&amp;mid=2650882346&amp;idx=1&amp;sn=b8a6d65936c082823c1615b6407139ed&amp;chksm=8c24f0bdbb5379ab54ef5c746ae778ed0e7637aece2f3700aea1cc4db4aaaf1e01c5f68cf7d9&amp;scene=132&amp;exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect">Ledoitand Wolf 的协方差矩阵收缩之旅</a></p><p><a href="https://mp.weixin.qq.com/s/XM4VzcSBmkVnq_YgujSrjg">协方差矩阵的估计和评价方法【天风金工因子选股系列之七】</a></p><p><a href="https://zhuanlan.zhihu.com/p/166111933">Machine Learning forAsset Managers 笔记-Chapter2 - 知乎 (zhihu.com)</a></p><h2 id="四协方差学习-1">四、协方差学习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用于记录我找到的好的学习资源，以便厘清学习的优先度&lt;/p&gt;
&lt;h2 id=&quot;一量化平台框架&quot;&gt;一、量化平台&amp;amp;框架&lt;/h2&gt;
&lt;h3 id=&quot;backtrader&quot;&gt;1.BackTrader&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com</summary>
      
    
    
    
    
    <category term="实习" scheme="https://nobodyyj.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>第一次高频交易比赛赛后感悟</title>
    <link href="https://nobodyyj.github.io/post/d5a2488e.html"/>
    <id>https://nobodyyj.github.io/post/d5a2488e.html</id>
    <published>2023-12-10T15:13:28.000Z</published>
    <updated>2023-12-10T15:50:15.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一次高频交易比赛赛后感悟"><a href="#第一次高频交易比赛赛后感悟" class="headerlink" title="第一次高频交易比赛赛后感悟"></a>第一次高频交易比赛赛后感悟</h1><p>​    我的第一次量化比赛参赛之旅在今天画上了句号，总共350+队伍只有前50能进复赛，我最后以rank 60止步初赛，感觉十分可惜。为了不浪费我这半个月来在高频研究熬的好几个夜，我决定赶在自己参赛经历淡忘前，趁热打铁写下我参加这个高频交易比赛的感悟。（2023.12.10，希望2024.12.10的我能干到决赛一雪前耻）。</p><p>​    本次参赛的感悟可分为技术栈、微观实盘、宏观策略和未来学习方向。</p><h2 id="一、技术栈"><a href="#一、技术栈" class="headerlink" title="一、技术栈"></a>一、技术栈</h2><p>​    这是我第一次与其他人合作代码，深刻认识到使用<strong>git</strong>进行代码协作的必要性。在版本回滚和合并多人工作成果方面，git的存在简直是雪中送炭，如果不使用这个工作流很可能项目会存在大量的<strong>bug和代码沟通障碍</strong>。</p><p>​    此外，cpp是进行高频交易必不可少的语言，即使使用并行、异步、numba等库能大大提高python语言的运行速度，但是归根到底还得是c &amp; cpp。在获取远程交易所信息的时候，需要熟悉如何使用并行、异步等库来减少请求等待时间。</p><h2 id="二、微观实盘"><a href="#二、微观实盘" class="headerlink" title="二、微观实盘"></a>二、微观实盘</h2><p>​    这个方面是导致我止步初赛最关键的原因。在高频交易中，我认为因子很可能是一个黑箱一样的存在。如果不去检测实盘交易后LOB的变化情况、也不去监控订单的执行状态（比如是否挂单成功、是否完全成交、是否撤单成果），策略的收益来源完全是凭运气的（2023.12.10下午求神拜佛希望自己持仓标的涨一涨这种傻X操作我希望止步于稚嫩的本科时代，太丢人了）。</p><p>​    以九坤的这次股票模拟交易比赛为例，下单、撤单、查询订单状态、获取股票实时LOB、获取User PnL、Sharpe等数据都是需要通过调用api接口的，而这个API接口是具有上限的。从流程上来说，我需要在交易信号发出后，找到标的的code输入buy price&amp;buy volume，并记录下response的order index，买单报单成功后，再根据order index查询订单的成交状态，交易成功后，再根据实时的盘口价格，计算出对应的sell price&amp;sell volume，报送给交易所。如果sell order报单成功，再记录下sell order的order index，再下一次开盘前or本次收盘后查询sell order的trade volume &amp;remain volume，完成实时头寸状态监控。比如如果我sell了800 shares，只有500share traded，还剩下的300share会冻结，如果此时bid price下跌，低于我的sell price，我的这部分头寸就必须要撤回再次挂出300share&amp;bid price1的卖单，<strong>否则就会存在风险敞口暴露，策略的收益被beta所取代</strong>。</p><p>​    除了这个订单管理系统之外，止盈止损、下单仓位控制等操作，也是非常重要的模块，如果不完善这几个模块，是没有办法控制好策略的pnl，甚至没有办法控制好策略的收益来源。</p><h2 id="三、宏观策略"><a href="#三、宏观策略" class="headerlink" title="三、宏观策略"></a>三、宏观策略</h2><p>​    宏观角度，本次比赛超脱了我所习惯的股票基本面信息，完全是从量价的角度来进行日内回转的股票交易。目前我认为，高频交易最重要的不是玩成梭哈式的读博游戏，而是通过高速执行的订单，完成短时间内的<strong>利润锁定</strong>o<strong>r回撤控制</strong>，这个比写出一个好的alpha更加重要。如果要做高频操作，一定要完善各个模块，厘清每一笔交易信号发出后，持仓标的、可用资金、多头市值是否符合自己的策略，这个环节在执行中真的是想起来简单做起来难。</p><h2 id="四、未来学习方向"><a href="#四、未来学习方向" class="headerlink" title="四、未来学习方向"></a>四、未来学习方向</h2><p>​    1.<strong>RL、DL，CNN、RNN类、GNN类、Tranformer、GAN</strong></p><p>​    2.机器学习对于混频因子的融合、</p><p>​    3.基于Markov转换的时序模型</p><p>​    4.做市商策略</p><p>​    5.幌骗策略</p><p>​    6.更优秀、高效、快速的订单管理数据存储格式，比如我现在用的是dataframe，因为groupby函数很高效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一次高频交易比赛赛后感悟&quot;&gt;&lt;a href=&quot;#第一次高频交易比赛赛后感悟&quot; class=&quot;headerlink&quot; title=&quot;第一次高频交易比赛赛后感悟&quot;&gt;&lt;/a&gt;第一次高频交易比赛赛后感悟&lt;/h1&gt;&lt;p&gt;​    我的第一次量化比赛参赛之旅在今天画上了句号</summary>
      
    
    
    
    
    <category term="高频" scheme="https://nobodyyj.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
    <category term="学习" scheme="https://nobodyyj.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>股票形态相似度研究</title>
    <link href="https://nobodyyj.github.io/post/32dc4a05.html"/>
    <id>https://nobodyyj.github.io/post/32dc4a05.html</id>
    <published>2023-11-28T13:33:27.000Z</published>
    <updated>2023-11-28T13:41:58.561Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red">1.东财数据+供应链数据</font></p><p><font color="red">2.对东财数据降噪处理，计算簇内</font></p><p><font color="red">3.在某一个时间节点，我们回看过去已知的概念数据or供应链数据</font></p><p><font color="red">机器学习做出来的效果不好，所以尝试对数据进行降噪处理</font></p><h1 id="section">11.27</h1><h3 id="具体操作">具体操作</h3><p>将概念算出来之后，得到每一天每个概念内股票的关系强度（比如等权的pearson系数），和宽基指数内的关系强度进行对比。可以尝试将concept内关系最弱的股票剔除，看概念内股票的关系有没有明显增强。</p><h3 id="先上手计算欧氏距离">先上手计算欧氏距离</h3><p>欧氏距离为常见的计算时间序列相似度的方法，该方法可以直接衡量两个时间序列之间的距离，其计算公式为:<span class="math display">\[D=\sqrt{\sum_{i=1}^N\left(X_i-Y_i\right)^2}\]</span></p><p>其中 <span class="math inline">\(\mathrm{N}\)</span> 为序列 <span class="math inline">\(\mathrm{X}\)</span> 和序列 <span class="math inline">\(\mathrm{Y}\)</span> 的长度。 由上述公式可以看出,若要计算两个序列之间的欧氏距离, 有两个局限性: 1、两个序列的长度需要相同,但在实际研究工作中, 找到满足上述条件的序列并非易事。2、该方法也无法进行异步相似度计算，因此会对实际上较为相似的两个时间序列其相似性做出误判。</p><h3 id="further-discussion">further discussion</h3><p>1.能不能做成因子</p><p>2.使用分钟频的数据是否会更有效？（or selected minutefrequency，比如volatility集聚现象重合）</p><h1 id="section-1">11.28</h1><p>从过往研究来看，度量时间序列相似性的方法大致分为4类：</p><p>第一类为<strong>基于特征的相似性度量方法</strong>，如相关系数、互信息等；第二类为<strong>锁步（时间序列“一对一”比较）的距离度量方法</strong>，典型方法有闵可夫斯基距离（可衍生为曼哈顿距离、欧氏距离、切比雪夫距离）、Hausdorff距离、余弦相似度等；第三类为<strong>弹性（允许时间序列“一对多”比较）的距离度量方法</strong>，代表方法为动态时间弯曲距离（DTW）、编辑距离（EDR）、最长公共子序列（LCSS）；第四类方法关注时间序列的<strong>变化相似性</strong>，如ARMA、HMM等。</p><h2 id="dtw">DTW</h2><h3 id="定义">定义</h3><p>对于时间序列 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> ，定义非负函数 <span class="math inline">\(f\)</span> 来衡量时间序列中的点 <span class="math inline">\(x \_\)</span>i和点 <span class="math inline">\(y\)</span> j的距离: <span class="math display">\[d(i, j)=f\left(x_{-} i, y \_j\right) \geq 0,\]</span></p><p>除常见的欧氏距离外，距离函数f也可以选取余弦相似度、汉明距离、曼哈顿距离、切比雪夫距离等其他距离度量方法。如果时间序列是多维的，则将每个维度的距离相加即可（确保各维度量纲一致）。</p><p>定义了时间序列中点与点的距离之后，两段时间序列即可形成一个 <span class="math inline">\(N \times M\)</span>的点阵，从点阵的右上角到左下角可以形成一条弯曲路径 (Warping Path)。</p><p>给定弯曲路径之后，便可以计算时间序列X和Y的标准化累计时间弯曲距离。另外，为了确保弯曲路径的合理性，通常需要满足3 大基本条件: - 终点条件 (EndpointConstraints)：要求弯曲路径的起点和终点必须为点阵平面的对角单元； -连续性条件 (Local ContinuityConstraints)：要求弯曲路径的每一步为相邻的单元（包括对角相邻单元)； -单调性条件 (MonotonicityConditions)：由于语音序列或证券交易数据等时间序列是有时序性的(时间不可倒流)，所以从实际意义出发，弯曲路径在点阵图上必须是单调的。</p><p>显然，满足以上3个条件的路径有很多条，选取哪条路径来计算DTW距离呢?一个很自然的想法是选取使得DTW距离最小的路径，具体推导过程需要利用动态规划算法（DynamicProgramming），这里不展开说明。最后，使得DTW距离最小化的最佳匹配路径需满足如下递归条件：<span class="math display">\[\delta(i, j)=d(i, j)+\min [\delta(i-1, j), \delta(i-1, j-1), \delta(i,j-1)]\]</span> <img src="/post/32dc4a05/640.png" alt="640"></p><h3 id="传统的dtw算法存在两点缺陷"><strong>传统的DTW算法存在两点缺陷</strong></h3><figure><img src="/post/32dc4a05/640%20(1).png" alt="640 (1)"><figcaption aria-hidden="true">640 (1)</figcaption></figure><p>1）算法对时间序列进行伸缩和平移时，可能存在过度伸缩或平移，产生时间序列点之间的“病态匹配”，如图8所示，B为两段时间序列的真实匹配情况，C为DTW算法下的匹配结果，显然较不合理，某些地方被过度平移和伸缩了</p><p>2）传统DTW算法运算量较大，时间复杂度较高。对于择时策略本身而言，显然第一个问题更加重要，如果不是高频策略，则运算复杂度对策略的影响不大，我们更关注距离度量的精度和策略实际效果。本节将针对“病态匹配”的问题对DTW算法做出改进，以提升匹配精度和策略效果。</p><hr><h3 id="病态匹配的改进方向">“病态匹配”的改进方向：</h3><p>加权DTW算法（Weighted Dynamic TimeWarping，WDTW）、导数DTW算法（Derivative Dynamic TimeWarping，DDTW）、步模式（Step Pattern）、全局约束（GlobalConstraints）</p><h4 id="全局约束-global-constraints">(1) 全局约束 (GlobalConstraints)</h4><p><strong>限制匹配路径尽可能接近对角线</strong>、<strong>对匹配路径整体进行限制</strong></p><p>传统的DTW算法允许匹配路径可以在图6中的点阵中任意生成（需满足上一节的3个基本条件），全局约束要求匹配路径只能在限定的区域内生成，常用的全局约束方法有Sakoe-ChibaConstraint和Itakura Parallelogram等。 Sakoe-ChibaConstraint，需设定窗口限制参数r，即最佳匹配路径须在距点阵对角线距离为r的区域内；ItakuraParallelogram将匹配路径限定在一个平行四边形区域中，平行四边形的四条边的斜率分别为2和0.5。</p><h4 id="局部约束local-constraints"><strong>(2) 局部约束（LocalConstraints）</strong></h4><p><strong>对匹配路径中每一步进行约束</strong></p><h5 id="a.步模式">a.<strong>步模式</strong></h5><p><strong>放松连续性条件，即可以与不相邻的点匹配，便能形成新的递归方式，即步模式</strong><img src="/post/32dc4a05/640%20(2).png" alt="640 (2)"></p><h5 id="b.加权方式">b.<strong>加权方式</strong></h5><figure><img src="/post/32dc4a05/640%20(3)-1701157416807-7.png" alt="640 (3)"><figcaption aria-hidden="true">640 (3)</figcaption></figure><p>模型有2个主要参数：序列长度l和距离阈值k，其中距离阈值k设置目的是当筛选相似的历史序列时，选取距离小于k的历史序列。若k选取过小，则会遗漏相似的历史序列；若k选取过大，则实际上不相似的历史序列也会被选入。</p><h3 id="我的问题">我的问题：</h3><p>1.能否利用聚类算法通过计算出DTW的相关度从而二次聚类？</p><p>做法参考：https://mp.weixin.qq.com/s/ODXny7pqV12LQ59TDkFkcQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font color=&quot;red&quot;&gt;1.东财数据+供应链数据&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;2.对东财数据降噪处理，计算簇内&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;3.在某一个时间节点，我们回看过去已知的概念数</summary>
      
    
    
    
    
    <category term="实习" scheme="https://nobodyyj.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>实习思考</title>
    <link href="https://nobodyyj.github.io/post/e850ef3b.html"/>
    <id>https://nobodyyj.github.io/post/e850ef3b.html</id>
    <published>2023-11-12T04:35:38.000Z</published>
    <updated>2024-01-15T16:13:08.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实习思考">实习思考</h1><h2 id="前言">前言</h2><p>​本文用来记录我在第一段量化实习中的思考，以及由此产生的关于学习方向的灵感。​update：2024-1-1600:10:57，最近和带教老师还有机器学习组的同事交流了一下，感觉量化的底层就是将多个不同频率信号的合成为一个超因子，在这个过程之后再基于金融、经济学的先验知识，对这个因子做风格、行业、换手率等方面的约束，<strong>信号合成</strong>才是关键。</p><h2 id="一对于整体">一、对于整体</h2><p>​“量化投资始终坚持以基本面为核心，同时结合价量信息的方式，立足从投资的本源看问题，以长期有效的逻辑出发构建基础框架，再与交易逻辑相融合。无论是基本面还是价量，对每一类信息都会深挖背后的逻辑与含义，在此基础上，采用传统数学建模与领先的人工智能和机器学习技术结合的方式，不断随着市场结构与交易行为进行优化迭代。”</p><p>1.是如何将基本面因子与量价因子结合的，使用有效前沿吗？</p><p>2.交易逻辑+基础框架，是指因子组合之后划分为某个风格框架吗？</p><p>3.因子表现较好的作为多因子框架的因子，表现较差的作为机器学习模型的因子吗？这两者是如何结合的呢，也是划分为某个风格的吗？如何判断市场结构和交易行为，这是涉及到根据微观结构调整权重吗？</p><h2 id="二挖因子">二、挖因子</h2><p>1.对于中低频的基本面因子，正确的挖掘模式是什么样的呢，有哪些挖掘方法，效率如何？</p><p>2.对于高频因子，如何判断因子是处于正常波动还是失效的状态</p><p>A:绩效归因</p><p>3.如何在收益率和可解释性（逻辑性）进行取舍</p><p>A:可解释性，以及如果sharpe够大也能直接怼。</p><h2 id="三因子组合">三、因子组合</h2><p>1.看完石川《因子投资方法与实践》后写</p><p>2.可以使用机器学习做组合优化。</p><blockquote><p>经典的多因子研究包括 alpha因子的挖掘和期货组合权重优化计算。市面常见的逻辑认为：任意期货都同时暴露于多种不同的风险因素下，这些风险因素的共同作用形成了期货合约价格的波动。通过对不同的风险因素以alpha因子的形式有效刻画，我们可以实现对期货收益率的分解，从而研究期货合约价格波动的原因。而最优的投资组合则应当是经过“剔除其余不稳定的因素干扰、充分暴露于alpha因子，并一般通过凸优化方法将对收益率的预测转化为组合权重”等若干步处理后的结果。这些步骤中也涉及到一些针对组合权重的约束条件的设置。</p></blockquote><p>技术栈：<code>凸优化层 cvxpylayers</code></p><p>简要来讲，它是一 个 python 库，在 CVXPY 的基础上整合了PyTorch、JAX和TensorFlow 的接口，便于用户在构造神经网络时来调用这些框架里的层以及建立可分的凸优化层。</p><p>3.要去计算single factor &amp; portfolio和Barra10因子的相关系数。</p><figure><img src="/post/e850ef3b/提取自中银证券_20201103-中银证券-中银证券量化权益投资系列报告（二）：有关Barra中国权益CNE5模型的思考（上）.png" alt="提取自中银证券_20201103-中银证券-中银证券量化权益投资系列报告（二）：有关Barra中国权益CNE5模型的思考（上）"><figcaption aria-hidden="true">提取自中银证券_20201103-中银证券-中银证券量化权益投资系列报告（二）：有关Barra中国权益CNE5模型的思考（上）</figcaption></figure><h2 id="四交易信号">四、交易信号</h2><h3 id="交易信号的分布需要服从norm吗">1.交易信号的分布需要服从norm吗？</h3><p>A：需要具体情况具体分析，比如需要分析异常值对应的标的是什么类型的。对于偏态厚尾信号的处理，可以使用powerrank，展成均匀分布后根据表现改变power分配头部alpha的权重。-2023.11.27</p><h3 id="根据计算出的alpha值如何分配position">2.根据计算出的alpha值如何分配position？</h3><p>A：INSN、过滤invalidpool后，对pwrk的alpha值的非nan值的头部50%做多、尾部50%做空。</p><p>目的：portfolio多空平衡、行业市值中性，尽量减少beta和在传统风格因子上的暴露。</p><h2 id="五回测框架">五、回测框架</h2><p><font color="blue">vn.py、Backtrader</font></p><p><strong><del>争取在2024年前使用backtrader跑一次回测</del></strong>已完成-2023.11.27</p><h2 id="六绩效归因">六、绩效归因</h2><p>Brison框架</p><h2 id="七宏观择时框架">七、宏观择时框架</h2><p>基于周期理论、宏观数据，划分金融市场属于哪个时域（用RegimeSwitching、HMM类似思想的ML、RL模型）</p><p>针对这个问题，优先了解<strong>Temporal RoutingAdaptor（TRA）</strong>模型。</p><blockquote><p>针对股票收益率预测任务，采用<strong>Temporal RoutingAdaptor（TRA）模型</strong>，用以识别不同的交易模式，直面“市场规律具有时变特性”这一核心问题。期望为每只股票，在每个时刻，都能找到与之相适应的股票收益率预测器或预测器组合，从而达到更优的预测效果。为了防止输出结果集中在个别预测器，借鉴了最优传输问题（OT）来指导路由器的学习。</p><p>TRA模型最早由微软亚洲研究院在 2021 年 6 月发布于 arXiv ，并被 2021 年KDD国际数据挖掘与知识发现大会接收。原模型代码已经封装在QLib里，感兴趣的投资者可以自行下载测试。本文在原模型基础上进行修改和优化。</p></blockquote><p><a href="https://mp.weixin.qq.com/s/pSdRtVVegwn5w5tu3IIreQ?poc_token=HOYAeGWjlNdg2VF8t711Tsb2T_4ztnGQDu24dHle">【专题研究】DFQ-TRA：多交易模式学习因子挖掘系统(qq.com)</a></p><p><a href="实习思考\国泰君安_20220511_主动专题报告_“板块配置轮盘”之初探——尝试搭建宏观因子和A股板块轮动间的桥梁_王大霁王鹤_20220511.pdf">国泰君安_20220511_主动专题报告_“板块配置轮盘”之初探——尝试搭建宏观因子和A股板块轮动间的桥梁_王大霁王鹤_20220511.pdf</a></p><h2 id="八rl调参">八、RL调参</h2><p>通过RL模型，选择合适的训练长度和预测长度，并且学习对应的可视化效果</p><p><strong>争取在2024年寒假跑一次机器学习模型来解决问这个问题</strong></p><h2 id="九qlib">九、Qlib</h2><p>争取跑通qlib平台上用到的code，至少理解有哪些包、对应的功能https://mp.weixin.qq.com/s/W2xRQHrwphbl1Um7_BkGgQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实习思考&quot;&gt;实习思考&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​
本文用来记录我在第一段量化实习中的思考，以及由此产生的关于学习方向的灵感。
​update：2024-1-16
00:10:57，最近和带教老师还有机器学习组的同事交流了一</summary>
      
    
    
    
    
    <category term="实习" scheme="https://nobodyyj.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>实习中的idea</title>
    <link href="https://nobodyyj.github.io/post/698179e8.html"/>
    <id>https://nobodyyj.github.io/post/698179e8.html</id>
    <published>2023-10-11T02:29:03.000Z</published>
    <updated>2023-11-28T13:11:20.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。"><a href="#1-如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。" class="headerlink" title="1.如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。"></a>1.如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。</h2><p>(考虑交易手数的话，需要解一个以最小化持仓误差为目标函数的、以总资金为硬约束的整数线性规划问题)</p><h2 id="2-利用alpha值生成持仓信号"><a href="#2-利用alpha值生成持仓信号" class="headerlink" title="2.利用alpha值生成持仓信号"></a>2.利用alpha值生成持仓信号</h2><p>在利用经过行业市值中性化、过滤掉涨跌停的final alpha values计算对应的持仓比例、多空持仓情况时，可以考虑使用power rank。<br><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cal_cs_rank</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> maxvalue<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>minvalue<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    部分经过删除处理    '''</span>    res <span class="token operator">=</span> np_nan_array<span class="token punctuation">(</span>shape <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">"float64"</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">-</span> np<span class="token punctuation">.</span>nanmin<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>nanmax<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>nanmin<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>maxvalue <span class="token operator">-</span> minvalue<span class="token punctuation">)</span> <span class="token operator">+</span> minvalue    <span class="token keyword">return</span> res  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>具体是把因子先利用rank函数展成(-1,1)的均匀分布形式，再根据对于头部权重的考虑，对展开后的值取3次方、5次方。</p><p><strong>1次方就是均匀分布</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plot_distribution<span class="token punctuation">(</span>Analyzer<span class="token punctuation">.</span>industry_analyze_detail<span class="token punctuation">(</span><span class="token string">'2021-03-29'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'factor'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">,</span><span class="token string">'power=1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/698179e8/1次.png" alt="1次"></p><p>取奇次幂可以放大头部权重</p><div class="table-container"><table><thead><tr><th>power=3</th><th>power=5</th></tr></thead><tbody><tr><td><code>plot_distribution(tmp**3,&#39;power=3&#39;)</code></td><td><code>plot_distribution(tmp**5,&#39;power=5&#39;)</code></td></tr><tr><td><img src="/post/698179e8/3次.png" alt="3次"></td><td><img src="/post/698179e8/5次.png" alt="5次"></td></tr></tbody></table></div><h2 id="3-回测计算的是单利"><a href="#3-回测计算的是单利" class="headerlink" title="3.回测计算的是单利"></a>3.回测计算的是单利</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">df<span class="token punctuation">[</span><span class="token string">'ac_returns'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">[</span><span class="token string">'returns'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-因子组合优化的最简单形式"><a href="#4-因子组合优化的最简单形式" class="headerlink" title="4.因子组合优化的最简单形式"></a>4.因子组合优化的最简单形式</h2><p>本报告根据模型滚动训练和预测的结果，将所有测试集上的预测结果作为最终合成的打分输出用于策略组合构建，每5个交易日进行一次调仓，仓位调整逻辑是在一定的约束条件下最大化加权模型预测打分值，同时限制组合的换手。每次调仓日的模型预测输出的股票得分向量记为 $\text{score}_{t}$，当期目标权重向量记为 $w_t$，优化目标方程为:</p><script type="math/tex; mode=display">\begin{aligned}& \max \left(\sum_{i=1}^n w_{t, i} * \text { score }_{t, i}-\alpha\left|w_t-w_{t-1}\right|\right) \\& \text { s.t }\left\{\begin{array}{l}-0.005 I \leq w_t-w_{\text {benchmark }} \leq 0.005 I \\\sum_{i=1}^n w_{t, i}=1 \\w_t \geq 0\end{array}\right.\end{aligned}</script><p>其中，$\alpha$用于约束换手率，取值 0.05 ；$ w_{benchmark}$为股票的基准权重向量； 1 是所有元素为 1 的长度为 $w_t$的向量，个股权重相对于基准成分股权重的偏离限制在正负 $0.5 \%$ 内。策略每 5 个交易日在收盘后通过上述优化目标和条件求解权重。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。&quot;&gt;&lt;a href=&quot;#1-如何根据市场交易规则（最小交易单位）来执行计算出的交易信号。&quot; class=&quot;headerlink&quot; title=&quot;1.如何根据市场交易规则（最小交易单位）来执行计算出的交</summary>
      
    
    
    
    
    <category term="实习" scheme="https://nobodyyj.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习记录</title>
    <link href="https://nobodyyj.github.io/post/77d962bf.html"/>
    <id>https://nobodyyj.github.io/post/77d962bf.html</id>
    <published>2023-09-28T03:44:11.000Z</published>
    <updated>2023-09-30T09:30:43.678Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文用来记录DBMS小白学习MySQL的过程</strong>。</p><p>学习资源链接：https://www.bilibili.com/video/BV1iq4y1u7vj?p=12&amp;vd_source=44ba9a7b92cb9c058705d88870afca92</p><h2 id="学习主线">学习主线：</h2><figure><img src="/post/77d962bf/image-20230928115341489.png" alt="image-20230928115341489"><figcaption aria-hidden="true">image-20230928115341489</figcaption></figure><h1 id="第03章_基本的select语句select非常重要">第03章_基本的SELECT语句（SELECT非常重要）</h1><h2 id="sql的分类">SQL的分类</h2><p>DDL:数据定义语言。CREATE  TRUNCATE DML:数据操作语言。INSERTDCL:数据控制语言。COMMIT </p><p>查询和更新指令构成了 SQL 的 DML部分（<strong>增删改查</strong>）：</p><ul><li><code>INSERT INTO</code> - 向数据库表中插入数据</li><li><code>DELETE</code> - 从数据库表中删除数据</li><li><code>UPDATE</code> - 更新数据库表中的数据</li><li><code>SELECT</code> - 从数据库表中获取数据</li></ul><p>SQL 的数据定义语言 (DDL)部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p><p>SQL 中最重要的 DDL 语句:</p><ul><li><code>CREATE DATABASE</code> - 创建新数据库</li><li><code>ALTER DATABASE</code> - 修改数据库</li><li><code>CREATE TABLE</code> - 创建新表</li><li><code>ALTER TABLE</code> - 变更（改变）数据库表</li><li><code>DROP TABLE</code> - 删除表</li><li><code>CREATE INDEX</code> - 创建索引（搜索键）</li><li><code>DROP INDEX</code> - 删除索引</li></ul><h2 id="sql的数据导入方法">SQL的数据导入方法</h2><h3 id="如果是使用cmd命令行">如果是使用cmd命令行</h3><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">mysql -u root -p # 进入mysql数据库source # + 文件的全部路径名，比如&quot;source d:\atguigudb.sql;&quot; use aiguigudb #运行sql文件，show tables;即可看到各表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="使用navicat时">使用Navicat时</h3><figure><img src="/post/77d962bf/image-20230930152422470.png" alt="image-20230930152422470"><figcaption aria-hidden="true">image-20230930152422470</figcaption></figure><p>右键图中atguiggudb，运行SQL文件</p><figure><img src="/post/77d962bf/image-20230930152602013.png" alt="image-20230930152602013"><figcaption aria-hidden="true">image-20230930152602013</figcaption></figure><p>然后刷新，表就会更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文用来记录DBMS小白学习MySQL的过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;学习资源链接：https://www.bilibili.com/video/BV1iq4y1u7vj?p=12&amp;amp;vd_source=44ba9a7b92cb9c0587</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于选校的一些想法</title>
    <link href="https://nobodyyj.github.io/post/8be97aef.html"/>
    <id>https://nobodyyj.github.io/post/8be97aef.html</id>
    <published>2023-09-19T16:21:28.000Z</published>
    <updated>2023-09-19T16:41:34.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于选校的一些想法"><a href="#关于选校的一些想法" class="headerlink" title="关于选校的一些想法"></a>关于选校的一些想法</h1><p>本来是打算好好学习MySQL和数据结构的，但是忽然入了贸大的量化投资方向，一下子要重新拿起尘封许久的数三和英语书，居然还要做PPT进行答辩，而且是在生日那天一大早背井离乡地进京赶考，不禁让我高强度刷xhs思考“我真的需要这份offer吗”</p><p>所以！</p><p><strong>我打算写下来一些我现在的想法，以便在2023年9月29号填系统的时候，帮助我进行选择。</strong></p><h2 id="央财的课程安排"><a href="#央财的课程安排" class="headerlink" title="央财的课程安排"></a>央财的课程安排</h2><p><img src="/post/8be97aef/3093f6a31047b074ce24b38c6ed22f8.jpg" alt="Alt text"></p><h2 id><a href="#" class="headerlink" title></a><img src="/post/8be97aef/b321ac910c9adac3696188bf2d59506.jpg" alt="Alt text"></h2><p>我的目标一定不是留在北京，而是利用在央财这段时间尽量打好机器学习的理论基础，把C++、DL、ML、optimization、SQL给学明白。尽早开始打kaggle比赛，以弥补因为地理位置而耽误的实习不足的问题。</p><p><strong>那么我为什么要去贸大呢！</strong></p><p>因为我真的好不放心央财！！！我是量化投资方向的小白鼠！如果发现因为实习导致找不到quant工作且家里不支持我去hk和坡，我就真得去银行了……我还是很想了解一下贸大的<strong>考核难度、课程设置、实习安排和毕业生去向</strong>的，而这些我在网上真的找不到相关的回答，看他们公布的去向都是四五年之前了（那时投行还是版本答案呢）。</p><p>写到这里，其实我已经做出了offer的选择，但是我一定不会浪费这笔支出，指定得把我看不出来的<strong>央财的培养方案的不足</strong>给挖出来，并且我得搞明白<strong>哪些是需要从实习中学到的，哪些是可以通过科研替代学习来掌握的</strong>，我认为掌握了这些问题的答案，是足以帮助我做出一个让我不会后悔的选择。</p><p>btw，千万不要“因为不喜欢A，而选择B”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于选校的一些想法&quot;&gt;&lt;a href=&quot;#关于选校的一些想法&quot; class=&quot;headerlink&quot; title=&quot;关于选校的一些想法&quot;&gt;&lt;/a&gt;关于选校的一些想法&lt;/h1&gt;&lt;p&gt;本来是打算好好学习MySQL和数据结构的，但是忽然入了贸大的量化投资方向，一下子要重</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>公司金融部分知识点</title>
    <link href="https://nobodyyj.github.io/post/9fac0702.html"/>
    <id>https://nobodyyj.github.io/post/9fac0702.html</id>
    <published>2023-09-17T14:56:02.000Z</published>
    <updated>2023-09-17T15:36:07.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公司金融知识点"><a href="#公司金融知识点" class="headerlink" title="公司金融知识点"></a>公司金融知识点</h1><h2 id="影响-beta-的几个因素（三个都是同向的）"><a href="#影响-beta-的几个因素（三个都是同向的）" class="headerlink" title="影响$\beta$的几个因素（三个都是同向的）"></a>影响$\beta$的几个因素（三个都是同向的）</h2><h3 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h3><h3 id="DOL（Degree-of-Operating-Levergae"><a href="#DOL（Degree-of-Operating-Levergae" class="headerlink" title="DOL（Degree of Operating Levergae)"></a>DOL（Degree of Operating Levergae)</h3><script type="math/tex; mode=display">D O L=\frac{\Delta E B I T / E B I T}{\Delta Q / Q}</script><p>其中，Q为产销量</p><script type="math/tex; mode=display">D O L=\frac{E B I T+F C}{E B I T}</script><p>FC是 总固定成本</p><h3 id="DFL（Degree-of-Financial-Leverage）"><a href="#DFL（Degree-of-Financial-Leverage）" class="headerlink" title="DFL（Degree of Financial Leverage）"></a>DFL（Degree of Financial Leverage）</h3><script type="math/tex; mode=display">D F L=\frac{\Delta E P S / E P S}{\Delta E B I T / E B I T}</script><p>其中，EPS是Earing Per Share，为本期税后净利润/正发行在外的普通股加权平均数</p><p>EBIT为Earing Before Interest and Tax，为净利润+利息+税</p><script type="math/tex; mode=display">D F L=\frac{E B I T}{E B I T-I}</script><p>其中，I为利息</p><h2 id="MM定理"><a href="#MM定理" class="headerlink" title="MM定理"></a>MM定理</h2><h3 id="无税"><a href="#无税" class="headerlink" title="无税"></a>无税</h3><p>1.资本结构不影响公司价值</p><script type="math/tex; mode=display">\text { 公司价值 = 负债的市场价值 }+\text { 权益的市场价值 }</script><p>2.股权的期望收益率 $r_E$ 和公司的杠杆结构 $\frac{D}{E}$ 成正比，比例系数为$r_A-r_D$</p><h3 id="有税"><a href="#有税" class="headerlink" title="有税"></a>有税</h3><p>1.</p><script type="math/tex; mode=display">\text { 公司价值 = 全股权融资时的价值 }+P V \text { (税盾) }</script><p><img src="https://cdn.niusouti.com/images/edcd8895fabcb605_img/3d7cda4ca7c9d6d4.png" alt="img"></p><p>2.</p><p>公司利息支付有税盾时，随负债增加，税后的WACC下降</p><p><img src="/post/9fac0702/1.png" alt="img-1"></p><h2 id="考虑有税的MM定理出现的三大结论"><a href="#考虑有税的MM定理出现的三大结论" class="headerlink" title="考虑有税的MM定理出现的三大结论"></a>考虑有税的MM定理出现的三大结论</h2><h3 id="权衡理论（静态权衡理论）"><a href="#权衡理论（静态权衡理论）" class="headerlink" title="权衡理论（静态权衡理论）"></a>权衡理论（静态权衡理论）</h3><p>把税盾效应和破产成本考虑进来，企业就会有一个最优的股权和债券融资比例，这边是资本结构的<u><strong>权衡理论</strong></u></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>公司在进行资本结构决策时，会权衡税盾的好处与财务困境成本，<strong>最大化公司价值</strong>。这种方法般被称为资本结构的权衡理论或静态权衡理论。（这边的公司价值实际上是指市场性索取权的价值）</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/post/9fac0702/2.png" alt="img-2"></p><p>上图展现了理论上的最优资本结构。税盾增加杜杆公司的价值, 财务困境成本降低杜杆公司的价 值。两个因素互相抵消, 在 $B^*$ 点产生最优债务额。</p><h4 id="税收对加权平均资本的影响"><a href="#税收对加权平均资本的影响" class="headerlink" title="税收对加权平均资本的影响"></a>税收对加权平均资本的影响</h4><p>根据静态权衡理论， $\boldsymbol{R}<em>{W A C C}$ 首先因为税盾的好处而下降。超过 $B^*$ 点后， $\boldsymbol{R}</em>{W A C C}$ 开始财务困境成本 而上升。<br><img src="/post/9fac0702/3.jpg" alt="img-3"></p><h3 id="优序融资理论"><a href="#优序融资理论" class="headerlink" title="优序融资理论"></a>优序融资理论</h3><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>优序融资理论亦译 “啄食顺序理论”。以信息不对称理论为基础, 并考虑交易成本的存在。公司 在为投资项目筹集资金时, 首先选择内部融资, 其次才考虑外部融资; 如果需要进行外部筹资, 公司 将首先选择高等级债务工具, 然后选择低等级债务工具, 例如可转换债券与可转换优先股, 最后才选 择普通股票。</p><h5 id="融资法则"><a href="#融资法则" class="headerlink" title="融资法则"></a>融资法则</h5><p><strong>(1) 法则 1:</strong> 采用内部融资<br>管理者在给权益和债务定价时, 都要担心投资者的怀疑态度, 因此先考虑内部融资。</p><p><strong>(2) 法则 2:</strong> <strong>先发行最稳健的证券</strong><br>与权益相比, 公司债务具有相对较小的风险, 因此, 需要外部融资时, 先发行稳健的债券, 在公 司达到一定的负债水平后再发行权益, 此外, 发行直接债务应先于发行可转换债, 最后再是股权。</p><p><strong>(3) 理论特点</strong><br>(1)不存在财务杠杆的目标值, 财务杜杆总额根据可利用项目随即决定。</p><h3 id="信号理论"><a href="#信号理论" class="headerlink" title="信号理论"></a>信号理论</h3><p>管理层改变公司杜杆时, 会传递某些信息。一般认为, 当管理层提高杜杆时, 意味着公司前景较好, 公司价值会提高。</p><h4 id="理性世界"><a href="#理性世界" class="headerlink" title="理性世界"></a>理性世界</h4><p>理性的企业预计其盈利将增加时, 会提高其负债水平; 理性的投资者把负债作为公司价值的一个信号, <strong>负债越多, 公司价值越高。</strong></p><h4 id="管理层愚弄投资者"><a href="#管理层愚弄投资者" class="headerlink" title="管理层愚弄投资者"></a>管理层愚弄投资者</h4><p>管理层愚弄投资者的动机一一公司可以通过承担额外的负债来愚弄投资者, 使投资者认为公司价值比实际的更大。但这种行为会增加成本, 使股价下跌。在管理层不会愚弄投资者的世界里, 价值高 的公司比价值低的公司发行更多的债券, 投资者把发债作为公司价值的正信号。</p><h2 id="金融摩擦（financial-frictions"><a href="#金融摩擦（financial-frictions" class="headerlink" title="金融摩擦（financial frictions)"></a>金融摩擦（financial frictions)</h2><p>信息不对称、期限错频、交易成本</p><h3 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h3><ol><li>事后——道德风险</li><li>事前——逆向选择</li></ol><h3 id="委托代理"><a href="#委托代理" class="headerlink" title="委托代理"></a>委托代理</h3><p>掌握信息的代理方</p><p>没有掌握信息的委托方</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公司金融知识点&quot;&gt;&lt;a href=&quot;#公司金融知识点&quot; class=&quot;headerlink&quot; title=&quot;公司金融知识点&quot;&gt;&lt;/a&gt;公司金融知识点&lt;/h1&gt;&lt;h2 id=&quot;影响-beta-的几个因素（三个都是同向的）&quot;&gt;&lt;a href=&quot;#影响-beta-的几个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建个人blog的资源&amp;遇到的问题及其解决方法</title>
    <link href="https://nobodyyj.github.io/post/7b3956b1.html"/>
    <id>https://nobodyyj.github.io/post/7b3956b1.html</id>
    <published>2023-09-17T14:17:26.000Z</published>
    <updated>2024-01-04T15:41:19.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用来记录自己学习搭建个人blog的资料遇到的问题及其解决方法">用来记录自己学习搭建个人blog的资料&amp;遇到的问题及其解决方法</h1><h2 id="学习资料">学习资料</h2><p><a href="http://haiyong.site/post/cda958f2.html">Hexo+阿里云&amp;GitHub搭建个人博客 | 海拥 (haiyong.site)</a></p><p>https://www.fomal.cc/posts/e593433d.html 主题：Butterfly <a href="https://butterfly.js.org/posts/4aa8abbe/#代碼高亮主題">Butterfly安裝文檔(三) 主題配置-1 | Butterfly</a></p><h2 id="目前遇到的问题">目前遇到的问题</h2><h3 id="图挂了">图挂了</h3><figure><img src="/post/7b3956b1/image-20230917220037303.png" alt="image-20230917220037303"><figcaption aria-hidden="true">image-20230917220037303</figcaption></figure><p><strong>解决方法</strong>：要使用相对路径“./搭建个人blog的资源-遇到的问题及其解决方法/image-20230917220037303.png”</p><h3 id="目录是乱的">目录是乱的</h3><p><img src="/post/7b3956b1/image-20230917220254151.png" alt="image-20230917220254151"><br><strong>解决方法</strong>：直接删除手动加上的数字，“# ##”会自动排序</p><h3 id="在多台电脑之间使用git进行数据同步时因为proxy问题报错">在多台电脑之间使用Git进行数据同步时因为proxy问题报错</h3><p>出现</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">fatal: unable to access &#39;XXX&#39;: Recv failure: Connection was reset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决办法：</strong></p><ol type="1"><li><p>依次将如下两条语句复制到git中后，点击回车</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">git config <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">global</span> <span class="token operator">-</span><span class="token operator">-</span>unset http<span class="token punctuation">.</span>proxy git config <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">global</span> <span class="token operator">-</span><span class="token operator">-</span>unset https<span class="token punctuation">.</span>proxygit config <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">global</span> http<span class="token punctuation">.</span>proxy http<span class="token punctuation">:</span><span class="token operator">//</span>手动设置代理荔枝<span class="token punctuation">:</span>端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在cmd中输入（用来清理DNS缓存）</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">ipconfig&#x2F;flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>正常输入</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">git add .git commit -m &quot;xxxx&quot;git push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="多台电脑之间协同工作的方法">多台电脑之间协同工作的方法</h3><p>摘自：https://xiaorui2.github.io/2019/05/25/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91/</p><p>思路：<strong>使用git分支</strong>。</p><h1 id="准备工作和环境要求">准备工作和环境要求</h1><p>在这之前，首先你得有台电脑是配置好了的，也就是确保你已经使用<code>hexo</code>在<code>github pages</code>上面部署好你的个人博客，并在本地电脑拥有该博客的部署环境，即类似于以下图片的文件目录</p><p><a href="https://xiaorui2.github.io/2019/05/25/Hexo博客多台电脑/1.png"><img src="https://xiaorui2.github.io/2019/05/25/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91/1.png" alt="img"></a></p><h1 id="对username.github.io仓库新建分支并克隆">对username.github.io仓库新建分支，并克隆</h1><p>在Github的<code>username.github.io</code>仓库上新建一个<code>xxx</code>分支，并切换到该分支，并在该仓库-&gt;<code>Settings</code>-&gt;<code>Branches</code>-&gt;<code>Default branch</code>中将默认分支设为<code>xxx</code>，<code>save</code>保存；然后将该仓库克隆（必须要用命令行）到本地，进入该<code>username.github.io</code>文件目录。</p><p>完成上面步骤后，在当前目录使用<code>Git Bash</code>执行<code>git branch</code>命令查看当前所在分支，应为新建的分支<code>xxx</code></p><h1 id="将本地博客的部署文件拷贝进username.github.io文件目录并提交">将本地博客的部署文件拷贝进username.github.io文件目录并提交</h1><p>将本地博客的部署文件全部拷贝进<code>username.github.io</code>文件目录，将拷贝进来的博客<code>hexo</code>部署环境提交到<code>xxx</code>分支，提交之前需注意：将<code>themes</code>目录以内中的主题的<code>.git</code>目录删除（如果有），因为一个<code>git</code>仓库中不能包含另一个<code>git</code>仓库，提交主题文件夹会失败。</p><p>执行<code>git add .</code>、<code>git commit -m 'back up hexo files'</code>（引号内容可改）、<code>git push</code>即可将博客的hexo部署环境提交到<code>GitHub</code>个人仓库的<code>xxx</code>分支。现在可以在GitHub上的<code>*username*.github.io</code>仓库看到两个分支的差异了。</p><p><code>master</code>分支和<code>xxx</code>分支各自保存着一个版本，<code>master</code>分支用于保存博客静态资源，提供博客页面供人访问；<code>xxx</code>分支用于备份博客部署文件，供自己维护更新，保证了两者在一个<code>GitHub</code>仓库内互不冲突。至此你搭配好的电脑上的任务就完成了。</p><h1 id="新电脑环境部署和更新">新电脑环境部署和更新</h1><p>首先你需要安装一下Hexo：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexonpm installnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后将新电脑的生成的<code>ssh key</code>添加到<code>GitHub</code>账户上</p><p>在新电脑上克隆<code>username.github.io</code>仓库的<code>xxx</code>分支到本地，此时本地git仓库处于<code>xxx</code>分支</p><p>切换到<code>username.github.io</code>目录，执行<code>npm install</code>(由于仓库有一个<code>.gitignore</code>文件，里面默认是忽略掉<code>node_modules</code>文件夹的，也就是说仓库的<code>hexo</code>分支并没有存储该目录[也不需要]，所以需要<code>install</code>下.</p><p>然后就可以正常的编辑、撰写文章或其他博客更新改动。</p><p>依次执行<code>git add .</code>、<code>git commit -m 'back up hexo files'</code>（引号内容可改）、<code>git push</code>指令，保证<code>xxx</code>分支版本最新</p><p>执行<code>hexo d -g</code>指令（在此之前，有时可能需要执行<code>hexo clean</code>），完成后就会发现，最新改动已经更新到<code>master</code>分支了，两个分支互不干扰！</p><p><strong>注意</strong>：每次<strong>换电脑进行博客更新</strong>时，不管上次在其他电脑有没有更新（就怕更新之后忘了），最好先<code>git pull</code>获取<code>xxx</code>分支的最新版本，之后再进行编辑和提交。</p><p><a href="https://codeantenna.com/a/YRLydjyz7L">git WorkFlow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用来记录自己学习搭建个人blog的资料遇到的问题及其解决方法&quot;&gt;用来记录自己学习搭建个人blog的资料&amp;amp;遇到的问题及其解决方法&lt;/h1&gt;
&lt;h2 id=&quot;学习资料&quot;&gt;学习资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://haiyong.site/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我国目前货币超发问题的看法</title>
    <link href="https://nobodyyj.github.io/post/bc16ba42.html"/>
    <id>https://nobodyyj.github.io/post/bc16ba42.html</id>
    <published>2023-09-16T16:00:00.000Z</published>
    <updated>2023-09-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://d.ifengimg.com/w1080_h1603_ablur_q90_webp/x0.ifengimg.com/ucms/2023_20/CC17DCD097C29014B4FAFFF6433FBD67836F22B0_size1038_w1080_h1603.png" alt="img"></p><h3 id="目前处于货币政策层面处于流动性陷阱"><a href="#目前处于货币政策层面处于流动性陷阱" class="headerlink" title="目前处于货币政策层面处于流动性陷阱"></a>目前处于货币政策层面处于流动性陷阱</h3><p>来源：<a href="https://finance.sina.com.cn/stock/roll/2023-06-10/doc-imywunmf0849027.shtml">通货紧缩了吗？樊纲：不，现在是流动性陷阱<em>新浪财经</em>新浪网 (sina.com.cn)</a></p><p>​        2023中国经济传媒大会上，针对目前经济复苏缓慢问题，中国经济体制改革会副会长、中国改革研究基金会秘书长樊纲指出，“现在的情况不是通货紧缩，而是出现了流动性陷阱。”</p><p>　　樊纲指出，通货紧缩是指货币数量的减少，导致需求不足，导致价格下降。<strong>但是前年我国货币增长速度已达8.7%，去年达11%，今年第一季度也达到12.7%，比过去大幅增长，在我们GDP只有4%增长的情况下，我们货币增发这么多，但这个时候却出现了价格下降，这不叫通货紧缩，而是叫做流动性陷阱。</strong></p><p>　　樊纲指出，流动性陷阱指的是你货币再多、融资成本再低，但如果预期投资回报更低的话，我们仍然不需要货币，不去投资，不去扩大需求，这就像货币掉进了一个黑洞，我们现在的情况就属于这种情况，就是企业、居民的需求不振。</p><p>​        </p><h3 id="为什么说我国会处于资产负债表衰退？"><a href="#为什么说我国会处于资产负债表衰退？" class="headerlink" title="为什么说我国会处于资产负债表衰退？"></a>为什么说我国会处于资产负债表衰退？</h3><p>1.从M2的增速和CPI、PPI数据可以看出，增量的货币并没有流入实际的市场，我认为的原因是钱被企业部分用于偿还负债，被民众用于储蓄，而没有用于扩大再生产或者实际消费。</p><p>2.对于企业，企业碍于国内外的政策风险，不敢投资扩大再生产，导致发展停滞，企业倾向于储蓄而非消费。同时，企业面临高杠杆的问题，在增长停滞之后面临巨大偿债压力，被迫采取去杠杆、降本增效的发展模式，所以我们会看到互联网大厂的裁员潮。</p><p>3.这也导致了私人部分的消费停滞。一方面，在就业环境不佳，薪资增幅降低，甚至面临裁员的风险下，民众消费欲望降低，储蓄欲望增强。（这点和企业是一样的，导致了活期存款的定期化，反映在M1-M2剪刀差的不断增大）。另一方面，中国的私人部门的杠杆率也很高，很多高收入群体都是背着房贷的，裁员潮会转变为断供潮。这点可以反映在不断增加的法拍房数据（2023年1-4月全国法拍房挂拍量为146549套，同比增长22.48%）上。这进而导致银行的贷款质量下降，进一步又加强了“融资难、钱荒”的情况。</p><p>为什么我国会面临现在的情况？</p><p>具体从分析的框架来说，可以从消费、投资、外贸三个角度来探。</p><h4 id="1-消费"><a href="#1-消费" class="headerlink" title="1.消费"></a>1.消费</h4><p>内需不足。具体来说，是企业发展压力传导至消费者，大家的预期转弱，储蓄欲望加强。</p><h4 id="2-投资"><a href="#2-投资" class="headerlink" title="2.投资"></a>2.投资</h4><p>投资风险大，收益低，没有好的投资机会。具体来说是企业没有好的投资机会。</p><h4 id="3-外贸"><a href="#3-外贸" class="headerlink" title="3.外贸"></a>3.外贸</h4><p>中美脱钩，东盟成为我们主要出口对象，对欧盟、美国、日韩出口下降。</p><p>出口的核心驱动是汽车制造业。</p><p>这主要是因为我们面临出生率暴跌，被迫采取限制房企无序融资，调控房价的政策。</p><h2 id="人口、房地产、杠杆三者的矛盾关系。"><a href="#人口、房地产、杠杆三者的矛盾关系。" class="headerlink" title="人口、房地产、杠杆三者的矛盾关系。"></a><strong>人口、房地产、杠杆三者的矛盾关系。</strong></h2><p>房价，行政手段干预导致价格信号失灵，会导致市场资源配置情况持续扭曲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://d.ifengimg.com/w1080_h1603_ablur_q90_webp/x0.ifengimg.com/ucms/2023_20/CC17DCD097C29014B4FAFFF6433FBD67836F22B0_size103</summary>
      
    
    
    
    
  </entry>
  
</feed>
